

# 正则
## 1、直接量字符
### 1-1、正则表达式中的直接量字符

| 字符           | 匹配                                                                                                                                |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 字母和数字字符 | 自身                                                                                                                                |
| \o             | NUL 字符(\u0000)                                                                                                                    |
| \f             | 换页符,等价于\x0c 和\cL                                                                                                             |
| \v             | 垂直制表符,等价于\x0b 和\cK                                                                                                         |
| \t             | 制表符,等价于\x09 和\cl                                                                                                             |
| \S             | 任何非空白字符，等价于[^\f\n\r\t\v]                                                                                                 |
| \n             | 换行符，等价于\x0a 和\cJ                                                                                                            |
| \cx            | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \s             | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。                      |
| \r             | 匹配一个回车符。等价于 \x0d 和 \cM。                                                                                                |

### 1-1、需要转义的字符

正则表达式中，许多标点符号具有特殊含义，如果使用需要转义。

```javascript
^$.*+?!:|\/()[]{}
```

## 2、字符类

- 将直接量字符单独放进方括号就组成了字符类。
- 通过^来定义否定字符类，用来匹配所有不包含再方括号中的字符
- 通过连字符来表示字符范围

如下：

```javascript
/[abc]/     //和字母a,b,c中任意一个都匹配。
/[^abc]/    //匹配a,b,c之外的所有字符
/[a-z]/ /[0-9]/ //分别匹配a-z的小写，0-9.
/[a-zA-Z0-9]/   //匹配任何数字和字母
```

正则表达式的字符类

| 字符   | 匹配                                                |
| ------ | --------------------------------------------------- |
| [...]  | 方括号中的任意字符                                  |
| [^...] | 除了方括号中的任意字符                              |
| .      | 除了换行符和其他 Unicode 行终止符之外的任意字符     |
| \w     | 任何的 ASCII 字符组成的单词，等价于[a-zA-Z0-9]      |
| \W     | 任何的不是 ASCII 字符组成的单词，等价于[^a-za-z0-9] |
| \s     | 任何 Unicode 空白符                                 |
| \S     | 任何非 Unicode 空白符的字符，注意\w 和\S 不同       |
| \d     | 任何 ASCII 数字，等价于[0-9]                        |
| \D     | 除了 ASCII 数字之外的任何字符，等价于[^0-9]         |
| [\b]   | 退格直接量（特例）                                  |

## 3、重复

正则表达式中的重复字符语法

| 字符  | 含义                                  |
| ----- | ------------------------------------- |
| {n,m} | 匹配前一项至少 n 次，但不能超过 m 次  |
| {n,}  | 匹配前一项 n 次或者更多次             |
| {n}   | 匹配前一项 n 次                       |
| ?     | 匹配前一项 0 次或者 1 次，等价于{0,1} |
| +     | 匹配前一项 1 次或多次，等价{1,}       |
| \*    | 匹配前一项 0 次或者多次，等价{0,}     |

```javascript
/\d{2,4}/      //匹配2-4个数字
/\w{3}\d?/      //精确匹配三个丹斯和一个可选的数字
/\s+javascript\s+/    //匹配前后带一个或者多个空格的字符串javascript
/[^(]*/             //匹配一个或者多个非左括号的字符
```

### 非贪婪的重复

上面的表中列出的匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，因此被称为贪婪匹配。只需再待匹配的字符后跟随一个问好即可实现非贪婪匹配。

```javascript
/a+/    //如果匹配aaa,会匹配三个字符aaa
/a+?/   //如果匹配aaa,只会匹配一个字符a
//匹配aaab时
/a+b/       //会匹配出aaab
/a+?b/      //同样会匹配出aaab 因为正则匹配，总是从能够匹配的第一个字符开始
```

## 4、选择、分组和引用

字符 "|" 用来分割供选择的字符。匹配规则从左到右，如果匹配到，即使后面的更更符合也不会再去匹配

```javascript
/ab|cd|ef/   //可以匹配字符串ab,cd,ef的任意一种情况
/\d{3}|[a-z]{4}/    //用来匹配三个数字或者四个小数
/a|ab/              //如果匹配ab之后匹配到a
```

### 圆括号的作用（一）

把单独的项组合成子表达式，以便可以像处理一个单独的单元那样用 "|"、"\*"、"+"和"?"等来对单元中的项进行处理

```javascript
/java(script)?/     //匹配字符串"java"，其后可以有"script"也可以没有
/(ab|cd)+|ef/       //可以匹配字符串 "ef",也可以匹配字符串"ab"和"cd"的一次或多次重复
```

### 圆括号的作用（二）

在完整的模式中定义子模式。在一个正则表达式成功的和目标字符串像匹配时，可以从目标中
抽出和圆括号中的子模式相匹配的部分。

假如需要检索一个或多个小写字母后面跟随意味或多位数字，但是我们比较关系后面的数字,可以像下面一样。后面会详细介绍重匹配中抽取数字。

```javascript
/[a-z]+\d+/
/[a-z]+(\d+)/
```

### 圆括号的作用（三）

允许同一个正则表达式的后面引用前面的子表达式。通过在字符 "\" 后面加以为或者多为数字来实现。这个数字制定了待圆括号的子表达式在正则总的位置。如 \1 引用第一个带圆括号的子表达式 \3 就是第三个带圆括号的子表达式

**对正则表达式的前一个子表达式的引用，并不是对子表达式模式的引用，而是指与那个模式相匹配的文本的引用**

```javascript
//下面的正则表达式匹配位于单引号或双引号之内的0个或者多个字符。但是，他们并不要求左侧和右侧的引号匹配(即，加入的两个引号都是单引号或都属双引号);
/['"][^'"]*['"]/
/(['"])[^'"]*\1/    //此时就要求前后的引号一样
```

\1 匹配的第一个带圆括号的子表达式所匹配的模式。在这个例子中，存在这样一条约束，那就是左侧的引号必须和右侧的引号像匹配。正则表达 hi 是不允许用双引号括起来的内用中有单引号，反之亦然。不能在字符类中使用下面的这种引用

```javascript
/(['"])[^\1]*\1/; //这种写法非法
```

如果使用 (?:...) 分组的表达式,代表不记忆与该项想匹配的字符串

### 正则表达式的选择、分组和引用字符

| 字符    | 含义                                                                                                                                   |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------- |
|         | 选择，匹配到该符合左边的子表达式或者右边的子表达式                                                                                     |
| (...)   | 组合，将几个项组合成一个单元，这个单元可以通过 "\*"、"+"、"?"和"                                                                       | "等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供后面的引用使用 |
| (?:...) | 只组合，把项组合到一个单元，但不记忆与该项相匹配的字符串                                                                               |
| \n      | 和第 n 个分组第一次匹配到的字符串想匹配，组是圆括号中的子表达式(也有可能是嵌套的)，组索引是从左到右的左括号数，以"(?:"形式的分组不编码 |

## 5、指定匹配位置

### 正则表达式中的锚字符

| 字符  | 含义                                                                                                          |
| ----- | ------------------------------------------------------------------------------------------------------------- |
| ^     | 匹配字符串的开头，在多行检索中，匹配一行的开头                                                                |
| \$    | 匹配字符串的结尾，在多行检索中，匹配一个行的结尾                                                              |
| \b    | 匹配一个单词的边界，简而言之，就是位于字符\w 和\W 之间的位置，或者位于字符\w 和字符串的开头或者结尾之间的位置 |
| \B    | 匹配非单词边界的位置                                                                                          |
| (?=p) | 零宽正向先行断言，要求接下来的字符都与 p 匹配，但不能包括匹配 p 的那些字符                                    |
| (?!p) | 零宽负向先行断言，要求接下来的字符不与 p 匹配                                                                 |

### 边界

具体如下：
/^JavaScript\$/用来匹配 JavaScript。但如果想匹配 Java 这个单词本身，可以使用正则表达式/\sJava\s/,可以匹配到前后都有空格的单词 "Java" 。但是存在问题

1.  如果"Java"出啊先在字符串的开始或者结尾，就匹配不成功，除非开始和结尾处各有一个空格
2.  当找到与之匹配的字符串时，它返回的匹配字符串的前端和后端都有空格。

因此可以使用单词的表姐\b 来代替真正的空格符 \s 进行匹配。\B 匹配锚点党委不是单词边界之处。
如下：

```javascript
/\B[Sscript]/
/\B[Ss]cript/.test('postscript')    //true
/\B[Ss]cript/.test('javascript')    //true
/\B[Ss]cript/.test('script')        //false
/\B[Ss]cript/.test('Scripting')     //false
```

### 先行断言

任意正则表达式都可以作为锚点条件。如果在符号 "(?=" 和 ")"之间加入一个表达式，它就是一个**先行断言**。用来说明圆括号总的表达式必须正确匹配，但并不是真正意义上的匹配。如下

```javascript
/[Jj]ava([Ss]cript)?(?=\:)/.test('javascript:console.log()')    //true
/[Jj]ava([Ss]cript)?(?=\:)/.test('java System.out')             //false 因为没有匹配到:
```

### 负向先行断言

带有 "(:!"的断言是负向先行断言，用来指定接下来的字符都不必匹配。如下：

```javascript
/Java(?!Script)([A-Z]\w*)/.test("JavaScript"); //false
//匹配任意的Java后面跟随一个大写字母和任意多个ASCII单词都为true
```

## 6、修饰符

语法的最后一个知识点，用来说明高级匹配模式的规则。
字符 | 含义
--------|-------
i | 执行不区分大小写的匹配
g | 执行全局匹配，即找到所有的匹配，而不是找到第一个之后就停止
m | 多行匹配模式，^匹配一行的开头和字符串的开头，\$匹配行的结束和字符串的结束

## 7、用于模式匹配的 String 方法

### search()

参数时一个正则表达式，返回第一个与之匹配的字符串的其实位置，如果找不到就返回-1

**注意：**
search 方法的参数如果不是正则表达式，则会通过 RegExp 构造函数将它转换成正则表达式。并且不支持全局检索，会自动忽略修饰符 g

### replace()

第一个参数时正则表达式，第二个参数是要进行替换的字符串。
替换的字符串可以插入下面特殊的变量名

| 变量名                              | 代表的值                                                                                                             |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| \$\$                                | 插入一个 "\$"。                                                                                                      |
| \$&                                 | 插入匹配的子串。                                                                                                     |
| \$` |插入当前匹配的子串左边的内容。 |
| \$'                                 | 插入当前匹配的子串右边的内容。                                                                                       |
| \$n                                 | 假如第一个参数是 RegExp 对象，并且 n 是个小于 100 的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从 1 开始 |

具体使用如下:

```javascript
console.log("ant,zone".replace(/(\w+),(\w+)/, "$2 $1")); //zone ant
console.log("ant88".replace(/(\d+)/, "$1 $&")); //ant88 88
console.log("ant88".replace(/(\d+)/, "$1$`")); //ant88ant  $`匹配左边的ant
console.log("88ant".replace(/(\d+)/, "$1$'")); //88antant  $'匹配到右边的ant
console.log("88ant".replace(/(\d+)/, "$$")); //$ant
```

replace 的其他使用见 MDN

### match()

接受一个正则表达式，返回一个有匹配结果组成的数组，如果正则表达式设置了修饰符 g,则返回的数组包含字符串中的所有匹配结果。

接受的参数分为三种情况：

1.  如果正则带有全局的修饰符 g 且没有分组(圆括号)时，返回的数组第一个参数时匹配到的值，同时还有其他的属性
2.  如果正则中含有全局修饰符 g，返回的时包含所有匹配到结果的数组
3.  如果含有分组(圆括号)是，返回的第一个参数是完整的匹配，后面存放的是圆括号括起来表达式相匹配的子串。

```javascript
console.log("1plus2equals3".match(/\d/)); //["1", index: 0, input: "1plus2equals3", groups: undefined]
console.log("1plus2equals3".match(/\d/g)); //["1", "2", "3"]

var url = /(\w+):\/\/([\w.]+)\/(\S*)/;
var text = "Visit  my blog at http://www.example.com/david";
console.log(text.match(url)); // ["http://www.example.com/david", "http", "www.example.com", "david", index: 18, input: "Visit  my blog at http://www.example.com/david", groups: undefined]
```

### exec()

和 match 传入不含全局修饰符时候的表现一样，不同的是有一个 lastIndex 属性。但是当正则表达式含有全局修饰符 g 时，正则会有一个 lastIndex 属性，下次的匹配会从 lastIndex 位置开始。

```javascript
var reg = /\d/g;
var text = "1plus2equals3";
var result;
while ((result = reg.exec(text))) {
  console.log(
    `Matched ${result[0]} at position ${result.index};next search begin at ${
      reg.lastIndex
    }`
  );
}

//Matched 1 at position 0;next search begin at 1
//Matched 2 at position 5;next search begin at 6
//Matched 3 at position 12;next search begin at 13
```

## ES6 正则的扩展

### u 修饰符

含义 Unicode 模式，用来正确处理大于\uFFFF 的字符。也就是可以正确处理 4 个字节的 UTF-16 编码

点(.)字符含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符

ES6 新增使用大括号表示 Unicode 字符表示法，这种表示法必须加上 u 修饰符才能识别大括号，否则会解读成量词。使用 u 修饰符之后，所以两次都会正确识别码点大于 0xFFFF 的 Unicode 字符

```javascript
/\u{61}/.test("a") / //false     被认为是识别61个连续的u
  a /
  u.test("a"); //true
```

### y 修饰符

y 修饰符作用和 g 修饰符类似，也是全局匹配，后一次的匹配从上一次匹配成功的下一个位置开始。不同的是，g 修饰符只要剩余位置中存在匹配就行，而 y 修饰符会确保匹配必须从剩余的第一个位置开始。

```javascript
var s = "aaa_aa_a";
var r1 = /a+/g;
console.log(r1.exec(s)); //['aaa']
console.log(r1.exec(s)); //['aa']
var r2 = /a+/y;
console.log(r2.exec(s)); //['aaa']
console.log(r2.exec(s)); //null 剩余第一个位置是_,因此匹配失败
```

### 后行断言和后行否定断言

```javascript
//后行断言
/(?<=y)x/          //x只有在y的后面才匹配 匹配的是x
/(?<=\$)\d+/       //只匹配美元后的数字
//后行否定断言
/(?<!y)x/           //只匹配x不再y后面
/(?<!\$)\d+/        //只匹配不再$后面的数字
```

### 具名组匹配

即给正则中的每个组起一个名字，如下

```javascript
const reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
console.log(reg.exec("2018-01-11"));
```

![](https://i.loli.net/2019/05/08/5cd2541ec31c6.jpg)

具名组匹配的引用 \k<组名>,同时\1 依然有效且可以同时使用。 如下所示：

```javascript
const reg = /^(?<word>[a-z]+)!\k<word>$/;
console.log(reg.test("abc!abc")); //true
console.log(reg.test("abc!ab")); //false
// \k 和 \1 同时使用
const reg = /^(?<word>[a-z]+)!\k<word>!\1$/;
console.log(reg.test("abc!abc!abc")); //true
console.log(reg.test("abc!abc!ab")); //false
```

## 一些好用的正则

### 时间格式化

```javascript
Date.prototype.format = function(fmt) {
  var o = {
    "M+": this.getMonth() + 1, //月份
    "d+": this.getDate(), //日
    "h+": this.getHours(), //小时
    "m+": this.getMinutes(), //分
    "s+": this.getSeconds(), //秒
    "q+": Math.floor((this.getMonth() + 3) / 3), //季度
    S: this.getMilliseconds() //毫秒
  };
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(
      RegExp.$1,
      (this.getFullYear() + "").substr(4 - RegExp.$1.length)
    );
  }
  for (var k in o) {
    if (new RegExp("(" + k + ")").test(fmt)) {
      fmt = fmt.replace(
        RegExp.$1,
        RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length)
      );
    }
  }
  return fmt;
};
```

### url 参数获取

```javascript
const obj = {};
location.search.replace(/([^?&=]+)=([^&]+)/g, (_, k, v) => (obj[k] = v));
```